package org.objectg.gen.rule;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

import org.objectg.conf.GenerationConfiguration;
import org.objectg.gen.GenerationRule;
import org.objectg.gen.RuleScope;
import org.objectg.gen.rule.range.Range;
import org.springframework.util.Assert;

/**
 * User: __nocach
 * Date: 29.9.12
 */
public class Rules {

    private static final JpaRule jpaRule = new JpaRule(RuleScope.INTERNAL_DEFAULT);
	/**
	 *
	 * @param value set exactly this value
	 * @param <T> value type
	 * @return rule that will always generate passed value
	 */
    public static <T> GenerationRule<T> value(T value){
        return sequence(value);
    }

	/**
	 *
	 * @param values values for sequence
	 * @return rule that will generate values from passed sequence of values. Values are
	 * returned in the order they are specified. If last value is reached, then sequence
	 * is used from the start.
	 */
    public static <T> GenerationRule<T> sequence(T... values){
        return new FromListGenerationRule<T>(values);
    }

	/**
	 *
	 * @param specificRules rules to use when generating value
	 * @return rule that will generate value with additional set of rules. SpecificRules will
	 * be used for generating values for given generation context
	 */
    public static GenerationRule specificRules(List<GenerationRule> specificRules) {
        return new RulesOverrideGenerationRule(specificRules);
    }

	/**
	 *
	 * @param clazzOfObjects type of the objects in {@link List}
	 * @return rule that will generate {@link List} with single element in it of type
	 * {@code clazzOfObjects}, that element will be generated by framework.
	 */
    public static GenerationRule listDefinition(Class clazzOfObjects) {
        return listDefinition(clazzOfObjects, 1);
    }

	/**
	 *
	 * @param clazzOfObjects type of the objects in {@link List}
	 * @param objectsInCollection how many objects to generate into list
	 * @return rule that will generate {@link List} with {@code objectsInCollection} elements in it of type
	 * {@code clazzOfObjects}, that elements will be generated by framework.
	 */
    public static GenerationRule listDefinition(Class clazzOfObjects, int objectsInCollection) {
        Assert.isTrue(objectsInCollection >= 0, "objectsInCollection must be >= 0");
        return new GenericListGenerationRule(clazzOfObjects, objectsInCollection);
    }

	/**
	 *
	 * @param values values to be added to the {@link List}
	 * @return rule that will generate {@link List} with supplied values.
	 */
    public static GenerationRule listDefinition(Object... values) {
        return new SingleValueGenerationRule(Arrays.asList(values));
    }

	/**
	 *
	 * @param collectionType type of the collection to create
	 * @param clazzOfObjects type of elements of the collection
	 * @return rule that will generate collection of type {@code collectionType} with single element of type
	 * {@code clazzOfObjects}.
	 */
    public static GenerationRule collectionDefinition(Class collectionType, Class clazzOfObjects){
        return new CollectionGenerationRule(collectionType, clazzOfObjects);
    }

	/**
	 *
	 * @param collectionType type of the collection to create
	 * @param clazzOfObjects type of elements of the collection
	 * @param objectsInCollection how many objects to generate into collection
	 * @return rule creating collection of the specified type
	 */
    public static GenerationRule collectionDefinition(Class collectionType, Class clazzOfObjects, int objectsInCollection){
		Assert.isTrue(objectsInCollection >= 0, "objectsInCollection >= 0");
        return new CollectionGenerationRule(collectionType, clazzOfObjects, objectsInCollection);
    }
	/**
	 *
	 * @param collectionType type of the collection to create
	 * @param values values that will be added to collection
	 * @return rule creating collection of the specified type
	 */
	public static GenerationRule collectionDefinition(Class collectionType, final Object... values) {
		return new CollectionGenerationRule(collectionType, values);
	}

	/**
	 *
	 * @param clazzOfObjects type of the objects in {@link java.util.Set}
	 * @return rule that will generate {@link java.util.Set} with single element in it of type
	 * {@code clazzOfObjects}, that element will be generated by framework.
	 */
    public static GenerationRule setDefinition(Class clazzOfObjects) {
        return setDefinition(clazzOfObjects, 1);
    }

	/**
	 *
	 * @param clazzOfObjects type of the objects in {@link java.util.Set}
	 * @param objectsInCollection how many objects to generate into set
	 * @return rule that will generate {@link java.util.Set} with {@code objectsInCollection} elements in it of type
	 * {@code clazzOfObjects}, that elements will be generated by framework.
	 */
    public static GenerationRule setDefinition(Class clazzOfObjects, int objectsInCollection) {
        Assert.isTrue(objectsInCollection >= 0, "objectsInCollection must be >= 0");
        return new GenericSetGenerationRule(clazzOfObjects, objectsInCollection);
    }
	/**
	 *
	 * @param values values to be added to the {@link java.util.Set}
	 * @return rule that will generate {@link java.util.Set} with supplied values.
	 */
    public static <T> GenerationRule setDefinition(T... values) {
        HashSet setWithValues = new HashSet();
        for (Object each: values){
            setWithValues.add(each);
        }
        return new SingleValueGenerationRule(setWithValues);
    }

	/**
	 *
	 * @return rule that will always generate null values
	 */
    public static GenerationRule onlyNull(){
        return new NullValueGenerationRule();
    }

	/**
	 *
	 * @return list of default rules used by framework
	 */
    public static List<GenerationRule> defaultRules(){
        List<GenerationRule> result = new ArrayList<GenerationRule>();
        result.add(jpaRule);
        return result;
    }

	/**
	 *
	 * @return rule that will generate empty collection for the context. If matched context
	 * isn't collection then object will be generated with empty collections.
	 */
    public static GenerationRule emptyCollections(){
        return new EmptyCollectionGenerationRule();
    }

	/**
	 *
	 * @return rule that will generate empty map for the context. If matched context
	 * isn't map then object will be generated with empty maps.
	 */
    public static GenerationRule emptyMaps(){
        return new EmptyMapCollectionGenerationRule();
    }

	/**
	 *
	 * @param contextTransformer not null
	 * @return permanent contextOverride rule
	 */
	public static GenerationRule contextOverride(GenerationContextTransformer contextTransformer){
		boolean permanent = true;
		return contextOverride(contextTransformer, permanent);
	}

	/**
	 *
	 * @param contextTransformer not null
	 * @param permanent if this rule should be permanent (will be present during whole generation)
	 * @return rule that will transform context and return value generated for the transformed context.
	 */
	public static GenerationRule contextOverride(GenerationContextTransformer contextTransformer
		, boolean permanent){
		return new OverrideContextGenerationRule(contextTransformer, permanent);
	}

	/**
	 *
	 * @return rule that will return object that is generated for the current context
	 */
	public static GenerationRule generatedObject() {
		return new SetGeneratedObjectGenerationRule();
	}

	/**
	 *
	 * @param configuration that must be used for generating value
	 * @return rule that will use passed configuration merged with the default one
	 */
	public static GenerationRule configurationOverride(final GenerationConfiguration configuration) {
		return new ConfigurationOverrideGenerationRule(configuration);
	}

	/**
	 *
	 * @param range not null. See {@link Range} and it's implementations
	 * @return rule that will use passed range for generating values
	 */
	public static GenerationRule range(Range<?> range) {
		return new RangeGenerationRule(range);
	}

	/**
	 *
	 * @return rule that will skip generation of value
	 */
	public static GenerationRule skip() {
		return new SkipGenerationRule();
	}
}
