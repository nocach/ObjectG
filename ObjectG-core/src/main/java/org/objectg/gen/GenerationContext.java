package org.objectg.gen;

import java.lang.reflect.Field;

/**
 * <p>
 *     Defines data under which Generation is performed. Used by {@link GeneratorRegistry}.
 * </p>
 * <p>
 * User: __nocach
 * Date: 28.8.12
 * </p>
 */
public class GenerationContext<T> {

    /**
     * optionall parentObject for which generation is performed
     */
    private Object parentObject;

    private Class classThatIsGenerated;
    private Field field;
    /**
     * contains classes and objects that WERE generated before current context
     */
    private Hierarchy hierarchy;
    private boolean isPushed;
    private Field parentField;
    private ExtendedPropertyDescriptor fieldPropertyDescriptor;

    GenerationContext(Class<T> classThatIsGenerated) {
        this(classThatIsGenerated, null);
    }
    GenerationContext(Class<T> classThatIsGenerated, Object parentObject) {
        this.classThatIsGenerated = classThatIsGenerated;
        this.parentObject = parentObject;
    }

    public Class<T> getClassThatIsGenerated() {
        return classThatIsGenerated;
    }

    public void setField(Field field) {
        this.field = field;
    }

    public Field getField() {
        return field;
    }

    public Object getParentObject() {
        return parentObject;
    }

    public boolean isCycle(){
        if (hierarchy == null) return false;
        return hierarchy.isCycle(classThatIsGenerated);
    }

    /**
     * @param clazz clazz that will be generated by the pushed context
     * @return new GenerationContext after pushing clazz
     */
    public <U> GenerationContext<U> push(Class<U> clazz){
        return push(clazz, null);
    }

    /**
     * @param clazz clazz that will be generated by the pushed context
     * @return new GenerationContext after pushing clazz
     */
    public <U> GenerationContext<U> push(Class<U> clazz, Object parentObject){
        GenerationContext<U> newContext = new GenerationContext(clazz, parentObject);
        newContext.hierarchy = hierarchy;
        newContext.hierarchy.push(classThatIsGenerated, parentObject);
        newContext.isPushed = true;
        newContext.setParentField(this.getField());
        return newContext;
    }

    public void pop(){
        if (isPushed) {
            hierarchy.pop();
            isPushed = false;
        }
    }

	@Override
	public String toString() {
		return "GenerationContext{" +
				"classGenerated=" + classThatIsGenerated.getName() +
				", parentObject=" + getSafeParentObjectString() +
				", field=" + field +
				", hierarchy.size=" + (hierarchy == null ? null : hierarchy.size()) +
				'}';
	}

	private String getSafeParentObjectString(){
		if (parentObject == null){
			return null;
		}
		//because parentObject can be still generated, it's toString can throw exceptions
		try{
			return parentObject.toString();
		}
		catch (Exception e){
			//ok, toString threw - record this
			return " parentObject.toString threw exception, parentObject.class="+parentObject.getClass().getSimpleName();
		}
	}

    /**
     *
     * @param clazz
     * @return the last object of type {@code clazz} that was generated in generation-hierarchy
     *          or null if no such object
     */
    public Object getLastGeneratedObject(Class clazz) {
        return hierarchy.pick(clazz);
    }

    public String dumpHierarchy() {
		if (hierarchy == null) return null;
        return hierarchy.dump();
    }

    public static GenerationContext createRoot(Class classThatIsGenerated){
        GenerationContext result = new GenerationContext(classThatIsGenerated);
        result.hierarchy = new Hierarchy();
        return result;
    }


    public boolean isPushed() {
        return isPushed;
    }

    public void setParentField(Field parentField) {
        this.parentField = parentField;
    }

    public Field getParentField(){
        return parentField;
    }

    public boolean isRoot(){
        return hierarchy.isEmpty();
    }

    public void setClassThatIsGenerated(Class<?> classThatIsGenerated) {
        this.classThatIsGenerated = classThatIsGenerated;
    }

    public void setFieldPropertyDescriptor(ExtendedPropertyDescriptor fieldPropertyDescriptor) {
        this.fieldPropertyDescriptor = fieldPropertyDescriptor;
    }

    public ExtendedPropertyDescriptor getFieldPropertyDescriptor() {
        return fieldPropertyDescriptor;
    }

    public void setParentObject(Object parentObject) {
        this.parentObject = parentObject;
    }

	public Object getRootObject() {
		return hierarchy.getRoot();
	}

	public int getCycleDepth() {
		if (!isCycle()) {
			throw new IllegalStateException("no cycle present");
		}
		return hierarchy.getCycleDepth(classThatIsGenerated);
	}

	public int getGenerationDepth() {
		if (hierarchy == null) return 0;
		return hierarchy.size();
	}
}
