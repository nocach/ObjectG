package org.objectg.gen;

import java.lang.reflect.Field;

import org.objectg.gen.access.PropertyAccessor;

/**
 * <p>
 *     Defines data under which Generation is performed.
 * </p>
 * <p>
 * User: __nocach
 * Date: 28.8.12
 * </p>
 */
public class GenerationContext<T> {

    /**
     * optionall parentObject for which generation is performed
     */
    private Object parentObject;

    private Class classThatIsGenerated;
    /**
     * contains classes and objects that WERE generated before current context
     */
    private Hierarchy hierarchy;
    private boolean isPushed;
    private Field parentField;
    private ExtendedPropertyDescriptor fieldPropertyDescriptor;
	private PropertyAccessor propertyAccessor;
	private PropertyAccessor parentPropertyAccessor;

	GenerationContext(Class<T> classThatIsGenerated) {
        this(classThatIsGenerated, null);
    }
    GenerationContext(Class<T> classThatIsGenerated, Object parentObject) {
        this.classThatIsGenerated = classThatIsGenerated;
        this.parentObject = parentObject;
    }

	/**
	 *
	 * @return type of the value being generated
	 */
    public Class<T> getClassThatIsGenerated() {
        return classThatIsGenerated;
    }

	/**
	 *
	 * @return owner of this property. Can be null when there is no owner.
	 */
    public Object getParentObject() {
        return parentObject;
    }

	/**
	 *
	 * @return true if currently generated object results in cycle
	 */
    public boolean isCycle(){
        if (hierarchy == null) return false;
        return hierarchy.isCycle(classThatIsGenerated);
    }

    /**
	 * Create new {@link GenerationContext} for the passed clazz. Pushing clazz into generation context means
	 * that previous object is no fully generated and another value should be generated (e.g. I'm generating
	 * object of class Person and find property Person.address, thus I should generate value address by pushing
	 * context with class Address.class).
	 *
     * @param clazz clazz that will be generated by the pushed context
     * @return new GenerationContext after pushing clazz
     */
    public <U> GenerationContext<U> push(Class<U> clazz){
        return push(clazz, null);
    }

	/**
	 * @param clazz clazz that will be generated by the pushed context
	 * @param parentObject optional parent object
	 * @return new GenerationContext after pushing clazz
	 */
	public <U> GenerationContext<U> push(Class<U> clazz, Object parentObject) {
		GenerationContext<U> newContext = new GenerationContext(clazz, parentObject);
		newContext.hierarchy = hierarchy;
		newContext.hierarchy.push(classThatIsGenerated, parentObject);
		newContext.isPushed = true;
		newContext.setParentPropertyAccessor(this.getPropertyAccessor());
		return newContext;
	}

	/**
	 * pop these context. Must be called when generation of this context was finished. Normally there is no need
	 * to call this method, for possible example on when to call refer to {@link org.objectg.gen.impl.ListGenerator}
	 */
    public void pop(){
        if (isPushed) {
            hierarchy.pop();
            isPushed = false;
        }
    }

	@Override
	public String toString() {
		return "GenerationContext{" +
				"classGenerated=" + classThatIsGenerated.getName() +
				", parentObject=" + getSafeParentObjectString() +
				", propertyAccessor=" + propertyAccessor +
				", hierarchy.size=" + (hierarchy == null ? null : hierarchy.size()) +
				'}';
	}

	private String getSafeParentObjectString(){
		if (parentObject == null){
			return null;
		}
		//because parentObject can be still generated, it's toString can throw exceptions
		try{
			return parentObject.toString();
		}
		catch (Exception e){
			//ok, toString threw - record this
			return " parentObject.toString threw exception, parentObject.class="+parentObject.getClass().getSimpleName();
		}
	}

    /**
     *
     * @param clazz
     * @return the last object of type {@code clazz} that was generated in generation-hierarchy
     *          or null if no such object
     */
    public Object getLastGeneratedObject(Class clazz) {
        return hierarchy.pick(clazz);
    }

	/**
	 *
	 * @return string representation of current generation hierarchy
	 */
    public String dumpHierarchy() {
		if (hierarchy == null) return null;
        return hierarchy.dump();
    }

    public boolean isPushed() {
        return isPushed;
    }


	/**
	 *
	 * @return true if this context will generate result object and this is not a subpart of it.
	 */
    public boolean isRoot(){
        return hierarchy.isEmpty();
    }

    public void setClassThatIsGenerated(Class<?> classThatIsGenerated) {
        this.classThatIsGenerated = classThatIsGenerated;
    }

	/**
	 *
	 * @param fieldPropertyDescriptor can be null. descriptor of the property for which this context exists
	 */
    public void setFieldPropertyDescriptor(ExtendedPropertyDescriptor fieldPropertyDescriptor) {
        this.fieldPropertyDescriptor = fieldPropertyDescriptor;
    }

    public ExtendedPropertyDescriptor getFieldPropertyDescriptor() {
        return fieldPropertyDescriptor;
    }

	/**
	 *
	 * @param parentObject can be null. parent object that owns property for which this context exists
	 */
    public void setParentObject(Object parentObject) {
        this.parentObject = parentObject;
    }

	/**
	 *
	 * @return object that is root for current generation
	 */
	public Object getRootObject() {
		return hierarchy.getRoot();
	}

	/**
	 *
	 * @return number of how many cycles this generation context represents
	 */
	public int getCycleDepth() {
		if (!isCycle()) {
			throw new IllegalStateException("no cycle present");
		}
		return hierarchy.getCycleDepth(classThatIsGenerated);
	}

	/**
	 *
	 * @return how deep we are in current generation hierarchy
	 */
	public int getGenerationDepth() {
		if (hierarchy == null) return 0;
		return hierarchy.size();
	}

	/**
	 *
	 * @param propertyAccessor will be used to set value generated for this context
	 */
	public void setPropertyAccessor(final PropertyAccessor propertyAccessor) {
		this.propertyAccessor = propertyAccessor;
	}

	public PropertyAccessor getPropertyAccessor() {
		return propertyAccessor;
	}

	/**
	 *
	 * @param parentPropertyAccessor will be used to access properties of parent object
	 */
	public void setParentPropertyAccessor(final PropertyAccessor parentPropertyAccessor) {
		this.parentPropertyAccessor = parentPropertyAccessor;
	}

	public PropertyAccessor getParentPropertyAccessor() {
		return parentPropertyAccessor;
	}

	/**
	 * Root generation context means that {@code classThatIsGenerated} starts whole new generation and will be it's
	 * main result
	 *
	 * @param classThatIsGenerated not null class for which this context is created
	 * @return root generation context
	 */
	public static GenerationContext createRoot(Class classThatIsGenerated){
		GenerationContext result = new GenerationContext(classThatIsGenerated);
		result.hierarchy = new Hierarchy();
		return result;
	}
}
