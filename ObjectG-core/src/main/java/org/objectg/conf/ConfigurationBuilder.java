package org.objectg.conf;

import org.hamcrest.Matcher;
import org.hamcrest.Matchers;
import org.objectg.conf.prototype.PrototypeCreator;
import org.objectg.gen.GenerationContext;
import org.objectg.gen.GenerationRule;
import org.objectg.gen.PostProcessor;
import org.objectg.gen.access.AccessStrategy;
import org.objectg.gen.cycle.CycleStrategy;
import org.objectg.gen.rule.Rules;
import org.objectg.matcher.ContextMatchers;
import org.objectg.matcher.ValueTypeHintMatcher;
import org.objectg.matcher.impl.GenerationContextFeatures;
import org.objectg.matcher.impl.JavaNativeTypeMatcher;
import org.springframework.util.Assert;

import static org.objectg.matcher.impl.GenerationContextFeatures.forIsRoot;

/**
 * <p>
 *     Builder allowing to quickly configure most common things in {@link GenerationConfiguration}.
 *     Use {@link org.objectg.ObjectG#config()} to create instances of this class.
 * </p>
 * <p>
 *     This Builder can be used not only in tests, but also to define configuration for
 *     {@link org.objectg.conf.defaults.AbstractObjectGConfiguration} and
 *     for local configuration {@link org.objectg.ObjectG#configLocal(GenerationConfiguration)}
 * </p>
 * <p>
 *     call {@link #done()} to create configuration itself
 * </p>
 * <p>
 * User: __nocach
 * Date: 29.9.12
 * </p>
 */
public class ConfigurationBuilder {
    private GenerationConfiguration resultConfiguration;
    private PrototypeCreator prototypeCreator;
	boolean notAllowObjectsInCollectionsChange = false;

    public ConfigurationBuilder(PrototypeCreator prototypeCreator){
        Assert.notNull(prototypeCreator, "prototypeCreator");
        this.prototypeCreator = prototypeCreator;
        resultConfiguration = new GenerationConfiguration();
    }

    /**
     * will set only primitive attributes ignoring any user-defined types.
     * collections, arrays and maps are still generated, but will be empty.
     */
    public ConfigurationBuilder onlyPrimitives() {
        GenerationRule nullForNotRootObjects = Rules.onlyNull();
		//for not native types set null
		//except the generated object
        nullForNotRootObjects.when(
                Matchers.<GenerationContext>allOf(
                        Matchers.not(GenerationContextFeatures.forClass(JavaNativeTypeMatcher.INSTANCE))
                        , forIsRoot(Matchers.is(false))
                )
        );
        resultConfiguration.addRule(nullForNotRootObjects);

		resultConfiguration.setObjectsInCollections(0);
		notAllowObjectsInCollectionsChange = true;

        return this;
    }

	/**
	 *
	 * @return built configuration
	 */
    public GenerationConfiguration done() {
        return resultConfiguration;
    }

	/**
	 * create {@link WhenBuilder} for the passed contextMatcher.
	 * @param contextMatcher see {@link ContextMatchers}. this context will be applied in returned {@link WhenBuilder}
	 * @return {@link WhenBuilder} for the passed contextMatcher.
	 */
	public WhenBuilder when(Matcher<GenerationContext> contextMatcher){
		return new WhenBuilder(contextMatcher, this);
	}

    /**
     * create {@link WhenBuilder} for the passed contextMatcher.
     * @param contextMatcher see {@link ContextMatchers}. this context will be applied in returned {@link WhenBuilder}
     * @param <U> type of the value that is expected to be generated by WhenBuilder.
 	 * @return {@link WhenBuilder} for the passed contextMatcher.
     */
    public <U> WhenBuilder<U> when(ValueTypeHintMatcher<GenerationContext, ? extends U> contextMatcher){
        return new WhenBuilder(contextMatcher, this);
    }

	/**
	 *
	 * @param classes list of classes for which returned {@link WhenBuilder} will be applied.
	 * @return {@link WhenBuilder} that will apply rules on objects of passed types.
	 */
    public <T> WhenBuilder<T> forClass(Class<? extends T>... classes){
        Assert.isTrue(classes.length > 0, "should be at least one class");
        Assert.noNullElements(classes, "should not contain null elements");
        return new WhenBuilder(ContextMatchers.typeOf(classes), this);
    }

    void addRule(GenerationRule rule) {
        Assert.notNull(rule, "rule");
        resultConfiguration.addRule(rule);
    }

    /**
     *
     * @param propertyExpression expression defining property for which this WhenBuilder will be applied.
     *                           collections and arrays are supported.
     *                           Example : {@code when("person2Address[0].owner.firstName)"}
	 * @return {@link WhenBuilder} that will apply rules on the object matched passed propertyExpression
     */
    public <T> WhenBuilder<T> when(String propertyExpression) {
        return new WhenBuilder<T>(propertyExpression, this);
    }

	/**
	 *
	 * @param postProcessor not null {@link PostProcessor}
	 */
    public ConfigurationBuilder addPostProcessor(PostProcessor postProcessor) {
        resultConfiguration.addPostProcessor(postProcessor);
        return this;
    }

    PrototypeCreator getPrototypeCreator() {
        return prototypeCreator;
    }

	/**
	 *
	 * @param clazz class of objects for which {@link WhenBuilder} will be applied.
	 * @return {@link WhenBuilder} that will apply rules on objects of passed type.
	 */
	public <T> WhenBuilder<T> when(final Class<T> clazz) {
		return new WhenBuilder<T>(ContextMatchers.typeOf(clazz), this);
	}

	/**
	 * define how many objects to generate for all collections
	 * @param objectsInCollection how many objects should be generated in collections (list, set, map, array)
	 *                            must be >= 0
	 */
	public ConfigurationBuilder setObjectsInCollection(final int objectsInCollection) {
		Assert.isTrue(objectsInCollection >= 0 , "objectsInCollection should be >= 0");
		Assert.isTrue(!notAllowObjectsInCollectionsChange, "can't change ObjectsInCollection after onlyPrimitives() was called");

		resultConfiguration.setObjectsInCollections(objectsInCollection);
		return this;
	}

	/**
	 * Default CycleStrategy is {@link org.objectg.gen.cycle.GoDeeperCycleStrategy} that will generate
	 * one additional object on cycle. So if properties Person.address and Address.person exist then
	 * 3 objects will be generated Person, Person.address and Person.address.person
	 * @return {@link CycleBuilder} for defining {@link CycleStrategy}
	 */
	public CycleBuilder onCycle() {
		return new CycleBuilder(this);
	}

	/**
	 * define cycle strategy to be used for cycles
	 * @param strategy not null strategy
	 */
	public ConfigurationBuilder setCycleStrategy(final CycleStrategy strategy) {
		resultConfiguration.setCycleStrategy(strategy);
		return this;
	}

	/**
	 *
	 * @param depth how deep to go into the object graph when generating root object
	 *              depth(0) means that only generating object will be created, any other not primitive field will
	 *              be omitted.
	 */
	public ConfigurationBuilder depth(final int depth) {
		Assert.isTrue(depth >= 0, "depth must be >= 0");
		resultConfiguration.setDepth(depth);
		return this;
	}

	/**
	 * set no limit generation depth
	 */
	public ConfigurationBuilder noDepth(){
		resultConfiguration.setDepth(GenerationConfiguration.UNLIMITED_DEPTH);
		return this;
	}

	/**
	 * define what access to use for setting generated values.
	 * @return {@link AccessBuilder}
	 */
	public AccessBuilder access() {
		return new AccessBuilder(this);
	}

	/**
	 * Default Access Strategy is {@link AccessStrategy#ONLY_FIELDS}
	 * @param accessStrategy not null
	 */
	public ConfigurationBuilder setAccessStrategy(final AccessStrategy accessStrategy) {
		Assert.notNull(accessStrategy, "accessStrategy should not be null");
		resultConfiguration.setAccessStrategy(accessStrategy);
		return this;
	}
}
